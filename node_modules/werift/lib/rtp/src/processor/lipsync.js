"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Max32bit = exports.ntpTime2Time = exports.LipSync = void 0;
const src_1 = require("../../../common/src");
const __1 = require("..");
const base_1 = require("./base");
// WIP
// todo impl
class LipSync extends base_1.Pipeline {
    constructor(clockRate, mismatch, streams) {
        super(streams);
        this.clockRate = clockRate;
        this.mismatch = mismatch;
        this.rtpPackets = {};
    }
    pushRtcpPackets(packets) {
        packets.forEach((sr) => {
            if (sr instanceof __1.RtcpSrPacket) {
                this.srReceived(sr);
            }
        });
        this.children?.pushRtcpPackets?.(packets);
    }
    srReceived(sr) {
        const { ntpTimestamp, rtpTimestamp } = sr.senderInfo;
        this.baseNtpTimestamp = ntpTimestamp;
        this.baseRtpTimestamp = rtpTimestamp;
    }
    pushRtpPackets(packets) {
        packets.forEach((p) => {
            this.rtpPackets[p.header.payloadType] =
                this.rtpPackets[p.header.payloadType] ?? [];
            this.rtpPackets[p.header.payloadType].push(p);
        });
        if (Object.keys(this.rtpPackets).length === 2) {
            const [a, b] = Object.values(this.rtpPackets);
            const lastA = this.calcNtpTime(a.slice(-1)[0].header.timestamp);
            const lastB = this.calcNtpTime(b.slice(-1)[0].header.timestamp);
            if (lastA == undefined || lastB == undefined) {
                this.children?.pushRtpPackets?.(packets);
            }
            else {
                //
            }
        }
    }
    calcNtpTime(rtpTimestamp) {
        if (!this.baseRtpTimestamp || !this.baseNtpTimestamp) {
            return;
        }
        // base rtpTimestamp is rollover
        if (rtpTimestamp - this.baseRtpTimestamp > exports.Max32bit - this.clockRate * 60) {
            this.baseRtpTimestamp += exports.Max32bit;
        }
        // target rtpTimestamp is rollover
        else if (rtpTimestamp + (exports.Max32bit - this.clockRate * 60) - this.baseRtpTimestamp <
            0) {
            rtpTimestamp += exports.Max32bit;
        }
        const elapsed = (rtpTimestamp - this.baseRtpTimestamp) / this.clockRate;
        return (0, exports.ntpTime2Time)(this.baseNtpTimestamp) + elapsed;
    }
}
exports.LipSync = LipSync;
const ntpTime2Time = (ntp) => {
    const [ntpSec, ntpMsec] = (0, src_1.bufferReader)((0, src_1.bufferWriter)([8], [ntp]), [4, 4]);
    return Number(`${ntpSec}.${ntpMsec}`);
};
exports.ntpTime2Time = ntpTime2Time;
/**4294967295 */
exports.Max32bit = Number((0x01n << 32n) - 1n);
//# sourceMappingURL=lipsync.js.map