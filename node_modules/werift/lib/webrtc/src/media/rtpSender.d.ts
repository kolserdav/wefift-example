/// <reference types="node" />
import Event from "rx.mini";
import { GenericNack, RedEncoder, RtcpPacket, RtpHeader, RtpPacket } from "../../../rtp/src";
import { RTCDtlsTransport } from "../transport/dtls";
import { Kind } from "../types/domain";
import { RTCRtpCodecParameters, RTCRtpSendParameters } from "./parameters";
import { SenderBandwidthEstimator } from "./sender/senderBWE";
import { MediaStreamTrack } from "./track";
export declare class RTCRtpSender {
    trackOrKind: Kind | MediaStreamTrack;
    readonly type = "sender";
    readonly kind: Kind;
    readonly ssrc: number;
    readonly rtxSsrc: number;
    streamId: string;
    readonly trackId: string;
    readonly onReady: Event<any[]>;
    readonly onRtcp: Event<[RtcpPacket]>;
    readonly onPictureLossIndication: Event<[]>;
    readonly onGenericNack: Event<[GenericNack]>;
    readonly senderBWE: SenderBandwidthEstimator;
    private cname?;
    private mid?;
    private rtpStreamId?;
    private repairedRtpStreamId?;
    private rtxPayloadType?;
    private rtxSequenceNumber;
    redRedundantPayloadType?: number;
    private _redDistance;
    redEncoder: RedEncoder;
    private headerExtensions;
    private disposeTrack?;
    private lsr?;
    private lsrTime;
    private ntpTimestamp;
    private rtpTimestamp;
    private octetCount;
    private packetCount;
    private rtt?;
    receiverEstimatedMaxBitrate: bigint;
    private sequenceNumber?;
    private timestamp?;
    private timestampOffset;
    private seqOffset;
    private rtpCache;
    codec?: RTCRtpCodecParameters;
    dtlsTransport: RTCDtlsTransport;
    private dtlsDisposer;
    track?: MediaStreamTrack;
    stopped: boolean;
    rtcpRunning: boolean;
    private rtcpCancel;
    constructor(trackOrKind: Kind | MediaStreamTrack);
    setDtlsTransport(dtlsTransport: RTCDtlsTransport): void;
    get redDistance(): number;
    set redDistance(n: number);
    prepareSend(params: RTCRtpSendParameters): void;
    registerTrack(track: MediaStreamTrack): void;
    replaceTrack(track: MediaStreamTrack | null): Promise<void>;
    stop(): void;
    runRtcp(): Promise<void>;
    replaceRTP({ sequenceNumber, timestamp, }: Pick<RtpHeader, "sequenceNumber" | "timestamp">): void;
    sendRtp(rtp: Buffer | RtpPacket): Promise<void>;
    handleRtcpPacket(rtcpPacket: RtcpPacket): void;
}
export declare function wrapRtx(packet: RtpPacket, payloadType: number, sequenceNumber: number, ssrc: number): RtpPacket;
