{"version":3,"file":"network.js","sourceRoot":"","sources":["../../../../common/src/network.ts"],"names":[],"mappings":";;;AAAA,iCAAiD;AAE1C,KAAK,UAAU,UAAU,CAAC,WAAuB,MAAM;IAC5D,MAAM,MAAM,GAAG,IAAA,oBAAY,EAAC,QAAQ,CAAC,CAAC;IAEtC,YAAY,CAAC,GAAG,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;IAEnC,MAAM,IAAI,OAAO,CAAO,CAAC,CAAC,EAAE,EAAE;QAC5B,MAAM,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC;QACxB,MAAM,CAAC,IAAI,CAAC,WAAW,EAAE,CAAC,CAAC,CAAC;IAC9B,CAAC,CAAC,CAAC;IAEH,MAAM,IAAI,GAAG,MAAM,CAAC,OAAO,EAAE,EAAE,IAAI,CAAC;IACpC,MAAM,IAAI,OAAO,CAAO,CAAC,CAAC,EAAE,EAAE,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IACxD,OAAO,IAAI,CAAC;AACd,CAAC;AAbD,gCAaC;AAEM,KAAK,UAAU,WAAW,CAAC,GAAW,EAAE,WAAuB,MAAM;IAC1E,OAAO,OAAO,CAAC,GAAG,CAAC,CAAC,GAAG,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;AACtE,CAAC;AAFD,kCAEC;AAEM,KAAK,UAAU,QAAQ,CAC5B,GAAW,EACX,GAAW,EACX,WAAuB,MAAM;IAE7B,IAAI,IAAwB,CAAC;IAE7B,KAAK,IAAI,CAAC,GAAG,GAAG,EAAE,CAAC,IAAI,GAAG,EAAE,CAAC,EAAE,EAAE;QAC/B,MAAM,MAAM,GAAG,IAAA,oBAAY,EAAC,QAAQ,CAAC,CAAC;QAEtC,YAAY,CAAC,GAAG,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;QAEnC,MAAM,IAAI,OAAO,CAAO,CAAC,CAAC,EAAE,EAAE;YAC5B,MAAM,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC;YACxB,MAAM,CAAC,IAAI,CAAC,WAAW,EAAE,CAAC,CAAC,CAAC;QAC9B,CAAC,CAAC,CAAC;QAEH,IAAI,GAAG,MAAM,CAAC,OAAO,EAAE,EAAE,IAAI,CAAC;QAC9B,MAAM,IAAI,OAAO,CAAO,CAAC,CAAC,EAAE,EAAE,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QACxD,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,EAAE;YAC9B,MAAM;SACP;KACF;IAED,IAAI,CAAC,IAAI;QAAE,MAAM,IAAI,KAAK,CAAC,gBAAgB,CAAC,CAAC;IAE7C,OAAO,IAAI,CAAC;AACd,CAAC;AA3BD,4BA2BC","sourcesContent":["import { createSocket, SocketType } from \"dgram\";\n\nexport async function randomPort(protocol: SocketType = \"udp4\") {\n  const socket = createSocket(protocol);\n\n  setImmediate(() => socket.bind(0));\n\n  await new Promise<void>((r) => {\n    socket.once(\"error\", r);\n    socket.once(\"listening\", r);\n  });\n\n  const port = socket.address()?.port;\n  await new Promise<void>((r) => socket.close(() => r()));\n  return port;\n}\n\nexport async function randomPorts(num: number, protocol: SocketType = \"udp4\") {\n  return Promise.all([...Array(num)].map(() => randomPort(protocol)));\n}\n\nexport async function findPort(\n  min: number,\n  max: number,\n  protocol: SocketType = \"udp4\"\n) {\n  let port: number | undefined;\n\n  for (let i = min; i <= max; i++) {\n    const socket = createSocket(protocol);\n\n    setImmediate(() => socket.bind(i));\n\n    await new Promise<void>((r) => {\n      socket.once(\"error\", r);\n      socket.once(\"listening\", r);\n    });\n\n    port = socket.address()?.port;\n    await new Promise<void>((r) => socket.close(() => r()));\n    if (min <= port && port <= max) {\n      break;\n    }\n  }\n\n  if (!port) throw new Error(\"port not found\");\n\n  return port;\n}\n"]}